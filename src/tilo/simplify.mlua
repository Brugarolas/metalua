
-- Simplify the constraints if possible, causes an error if the
-- constraints can't be satisfied.
-- The simplification is more restrictive than the original gamma,
-- it converts some "<:" constraints into "==" ones,
-- get sane types.

require 'tilo.gamma'
local compare = require 'tilo.compare'
local GAMMA = getmetatable(gamma_new()).__index


-- Predicate: whether term `x` is a variable, as opposed as any
-- other expression types, including primitive types such as
-- `Tid 'number'.
local function is_var(self, x)
    checks('gamma', 'te')
    return x.tag=='TId' and not self.prim_types[x[1]] and x[1]
end

-- Iterates over pairs of variables represented in x.
-- x must be an `eq` or `sub_*` subfield of gamma.
-- Returns the variable names, as two strings.
local function var_pairs(self, x)
    checks('gamma', 'gamma.constraint')
    local var_term_iterate = x :var_term_pairs()
    local function iterate()
        local var, term = var_term_iterate()
        if var==nil then return nil, nil
        elseif is_var(self, term) then return var, term[1]
        else return iterate() end
    end
    return iterate
end


-- Closes the variable equality relationship in gamma:
-- returns a table canonical name -> synonym names set
local function canonize_te_vars (self)
    checks('gamma')

    -- 1/ Build direct synonyms table
    local synonyms = { } -- name -> name set
    for v1, v2 in var_pairs(self, self.te.eq) do
        local synonyms_v1=synonyms[v1]
        if synonyms_v1 then synonyms_v1[v2]=true
        else synonyms[v1]={ [v1]=true, [v2]=true } end
    end


    -- Flatten synonyms.
    -- (find a single representant for each equality class).
    repeat
        local again = false
        local v1 = next(synonyms)
        local synonyms_v1 = synonyms[v1]
        for v2 in pairs(synonyms_v1) do
            local synonyms_v2 = synonyms[v2]
            if v1~=v2 and synonyms_v2 then -- move synonyms from v2 to v1
                again=true
                for v3 in pairs(synonyms_v2) do 
                    synonyms_v1[v3]=true
                end
                synonyms[v2] = nil -- remove them from v2
            end
        end
    until not again
    return synonyms
end

function GAMMA :simplify()

    -- Convert v1<:v2 constraints into v1==v2
    for _, sub in ipairs{self.te.sub_pos, self.te.sub_neg} do
        for v, t in sub :var_term_pairs() do
            if t.tag=='TId' and not self.prim_types[t[1]] then
                self.te.eq :add (v, t)
                sub :remove(v, t)
            end
        end
    end

print "After <:> --> ==:"
print(self :tostring())

    local synonyms = canonize_te_vars(self)

-- Debug trace
print "synonyms:"
for v, set in pairs(synonyms) do
    local lst = { }
    for x in pairs(set) do table.insert(lst, x) end
    printf("%s -> %s", v, table.concat(lst, ', '))
end
print "After closing eq:"
print(self :tostring())

    -- Move all relationships to the canonical variable.
    for _, rel in ipairs{ self.te.eq, self.te.sub_pos, self.te.sub_neg } do
        for v1, synonyms_v1 in pairs(synonyms) do
            local new_terms_v1 = { }
            for v2 in pairs(synonyms_v1) do
                -- Add to v1
                for _, term in ipairs(rel[v2] or { }) do
                    table.insert(new_terms_v1, term)
                end
                rel[v2] = nil -- Remove from v2
            end
            rel[v1] = new_terms_v1
        end
    end

print "After moving constraints:"
print(self :tostring())

    -- Collect upper bounds of variables: get the min of
    -- non-variables (v <: t_n forall n ==> v <: min(t_n forall n)),
    -- unless t_n is a variable.
    local upper_bounds = { }
    for name, items in self.te.sub_pos:lists() do
        local supers = { } -- types bigger than item
        for _, item in ipairs(items) do
            if not is_var(self, item) then table.insert(supers, item) end
        end
        --table.print(supers)
        if next(supers) then
            local super = compare.min.te(unpack(supers))
            if not super then 
                local args = table.imap(a2s, supers)
                args = table.concat(args, ', ')
                local msg = "Can't find "..name.." = min("..args..')'
                error(msg)
            end
            upper_bounds[name] = super
        end
    end

    -- Collect upper bounds of variables: get the max of
    -- non-variables (v :> t_n forall n ==> v :> max(t_n forall n)),
    -- unless t_n is a variable.
    local lower_bounds = { }
    for name, items in self.te.sub_neg :lists() do
        local subs = { }
        for _, item in ipairs(items) do
            if not is_var(self, item) then table.insert(subs, item) end
        end
        if next(subs) then
            local sub = compare.max.te(unpack(subs))
            if not sub then
                local args = table.imap(a2s, subs)
                args = table.concat(args, ', ')
                local msg = "Can't find "..name.." = max("..args..')'
                error(msg)
            end
            lower_bounds[name] = sub
        end
    end

    -- Check that upper bounds don't violate lower bound constraints,
    -- change tham into equalities (v<:t ==> v==t)
    for name, upper in pairs(upper_bounds) do
        local lower = lower_bounds[name]
        if lower then printf("TODO: check %s <: %s", a2s(lower), a2s(upper)) end
        self.te.eq :add (name, upper)
    end

    -- Re-establish equalities between synonyms
    for v1, synonyms_v1 in pairs(synonyms) do
        local only_v1 = { [`TId{ v1 }] = true }
        for v2 in pairs(synonyms_v1) do
            self.te.eq[v2]=only_v1
        end
    end

    for var, min in pairs(upper_bounds) do
        self.te.sub_pos[var] = { min }
        --table.print(var)
        --table.print(min)
    end
    for var, max in pairs(lower_bounds) do
        self.te.sub_neg[var] = { max }
    end

    local compare = require 'tilo.compare'
    local sigma_vars = { }
    
    -- TODO: not useful anymore
    -- Reverse synonyms: associates to each var its canonical one.
    -- representant[v] = canonical representant of
    local canonical = { }
    for v1, synonyms_v1 in pairs(synonyms) do
        for v2 in pairs(synonyms_v1) do
            canonical[v2] = v1
        end
    end

    -- Perform type substitutions on term variables
    for var, tf in pairs(self.var_types) do
    --    compare.subst(tf, sigma_vars)
    end

end