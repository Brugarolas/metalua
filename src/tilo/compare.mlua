require 'tilo.gamma'

-{extension 'match'}

-- Combines table fields: takes two `TTable, return a table
-- with arbitrary keys, and as values, triplets { key, tf1, tf2 }
-- where field types are substituted with defaults when missing.
-- For instance, 
-- combine_fields([Fad; P1:Fa1; P2:Fa2], [Fbd; P1:Fb1; P3:Fb3]) =
-- { [_1]: {P1, Fa1, Fb1}; [_2]: {P2, Fa2, Fad]; [_3]: {P3, Fad, Fb3} }
--
local function combine_fields(ta, tb)
    checks('te', 'te')
    -- Helper to match fields lists together
    local function canonize(key)
        checks('p')
        return key[1] and key.tag..' '..key[1] or key.tag
    end
    local da, pa = unpack(ta)
    local db, pb = unpack(tb)
    local fp = { } -- field pairs, by key, indexed by canonized key
    for _, item in ipairs(pa) do
        local key, tf = unpack(item)
        fp[canonize(key)] = { key, tf, db }
    end
    for _, item in ipairs(pb) do
        local key, tf = unpack(item)
        local ck = canonize(key)
        local x = fp[ck]
        if x then x[3] = tf else fp[ck]= { key, da, tf } end
    end
    return fp
end

local eq = { }

function eq.ast(a,b)
    if a==b then return true
    elseif type(a) ~= 'table' then return false
    elseif type(b) ~= 'table' then return false
    elseif a.tag~=b.tag then return false
    elseif #a ~= #b then return false end
    for i=1,#a do if not eq.ast(a[i], b[i]) then return false end end
    return true
end

function eq.te(a, b)
    checks('te', 'te')
    if eq.ast(a, b) then return true end
    match a, b with
    | `TFunction{ pa, ra }, `TFuntion{ pb, rb } ->
        return eq.tebar(pa, pb) and eq.tebar(ra, rb)
    | `TTable{ da, pa, ua }, `TTable{ db, pb, ub } ->
        if not eq.tf(da, db) or not ua ~= not ub then return false end
        for _, item in pairs(combine_fields(a, b)) do
            local k, tfa, tfb = unpack(item)
            if not eq.tf(tfa, tfb) then return false end
        end
        return true
    | _, _ -> return false
    end
end

function eq.tf(a, b)
    checks('tf', 'tf')
    return a==b or a.tag==b.tag and eq.te(a[1], b[1])
end

function eq.tebar(a, b)
    checks('tebar', 'tebar')
    if a.tag or a.tag then return false end
    local n = math.max(#a, #b)
    local r = { }
    for i=1, n do
        local ta = a[i] or `TId 'nil'
        local tb = b[i] or `TId 'nil'
        if not eq.te(ta, tb) then return false end
    end
    return true
end

local minmax = { }

function minmax.te(this_op, opposite_op, a, b)
    if eq.te(a, b) then return a end
    match a, b with
    | `TFunction{ pa, ra }, `TFunction{ pb, rb } ->
        local pc = opposite_op.tebar(pa, pb)
        if not pc then return false end
        local rc = this_op.tebar(ra, rb)
        if not rc then return false
        else return `TFunction{ pc, rc } end
    | `TTable{ da, pa, ua }, `TTable{ db, pb, ub } ->
        local dc = this_op.tf(da, db)
        if not dc then return false end
        local cf = combine_field_tables(a, b)
        local pc = { }
        for _, item in pairs(fp) do
            local k, fa, fb = unpack(item)
            local tf = this_op.tf(fa, fb)
            if not tf then return false
            elseif not eq.tf(tf, dc) then table.insert(pc, `TPair{ k, tf}) end
        end
        local uc = ua and ub
        return `TTable{ dc, pc, uc }
    | _, _ -> return false
    end
end

function minmax.tebar(this_op, opposite_op, tebar1, tebar2)
    if tebar1.tag or tebar2.tag then return false end
    local n = math.max(#tebar1, #tebar2)
    local r = { }
    for i=1, n do
        local ta = tebar1[i] or `TId 'nil'
        local tb = tebar2[i] or `TId 'nil'
        local tc = this_op.te(ta, tb)
        if not tc then return false end
        r[i]=tc
    end
    -- Remove useless nils at end of sequence
    while(r[n].tag=='TId' and r[n][1]=='nil') do
        table.remove(r); n=n-1
    end
    return r
end

function minmax.tf(tf1, tf2)
    match tf1, tf2 with
    | `TField, `TField -> return tf1
    | `TField, tf ->
        return this_op.name == 'min' and tf or `TField
    | `TVar{te1}, `TVar{te2} | `TCurrently{te1}, `TCurrently{te2} ->
        if eq.te(te1, te2) then return tf1 else return false end
    | `TConst{te1}, `TConst{te2} ->
        local te = this_op.te(te1, te2)
        if te then return `TConst{ te } else return false end
    | `TVar{ te1 }, `TConst{ te2 } | `TConst{ te2 }, `TVar{ te1 } ->
        local te = this_op.te(te1, te2)
        if not te then return false end
        local tag = this_op.name == 'min' and 'TVar' or 'TConst'
        return { tag=tag; te }
    | _, _ -> return false
    end
end

local function fold(op2, k)
    return function(...)
        local args  = {...}
        local nargs = #args
        if     nargs==0 then return op2.ultimum
        elseif nargs==1 then return ... else
            local f = op2[k]
            local x = f(args[1], args[2])
            for i=3, nargs do
                if not x then return false end
                x = f(x, args[i])
            end
            return x
        end
    end
end

local min, max = { }, { }
local min2 = { name='min', ultimum=false }
local max2 = { name='max', ultimum=`TField }
for _, k in ipairs{ 'te', 'tf', 'tebar', 'ts' } do
    min2[k] = |...| minmax[k] (min2, max2, ...)
    max2[k] = |...| minmax[k] (max2, min2, ...)
    min[k] = fold(min2, k)
    max[k] = fold(max2, k)
end

return { eq=eq, min=min, max=max }