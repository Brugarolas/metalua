-- equal, min, max operators on types.

-{extension 'match'}

local eq = { }

-- Structural equality between arbitrary ASTs. No semantic awareness,
-- e.g. table fields won't be reordered nor expanded.
function eq.ast(a,b)
    if a==b then return true
    elseif type(a) ~= 'table' then return false
    elseif type(b) ~= 'table' then return false
    elseif a.tag~=b.tag then return false
    elseif #a ~= #b then return false end
    for i=1,#a do if not eq.ast(a[i], b[i]) then return false end end
    return true
end

-- Equality between expression types.
function eq.te(a, b)
    checks('te', 'te')
    if eq.ast(a, b) then return true end
    match a, b with
    | `TFunction{ pa, ra }, `TFuntion{ pb, rb } ->
        return eq.tebar(pa, pb) and eq.tebar(ra, rb)
    | `TTable{ da, pa }, `TTable{ db, pb } ->
        if not eq.tf(da, db) then return false end
        for tfa, tfb, k in field_pairs(a, b) do
            if not eq.tf(tfa, tfb) then return false end
        end
        return true
    | _, _ -> return false
    end
end

-- Equality between field types.
function eq.tf(a, b)
    checks('tf', 'tf')
    return a==b or
        a.tag==b.tag and (a.tag=='TField' or eq.te(a[1], b[1]))
end

-- Equality between expression sequence types.
function eq.tebar(a, b)
    checks('tebar', 'tebar')
    if a.tag or a.tag then return false end
    local n = math.max(#a, #b)
    local r = { }
    for i=1, n do
        local ta = a[i] or `TId 'nil'
        local tb = b[i] or `TId 'nil'
        if not eq.te(ta, tb) then return false end
    end
    return true
end

-- Min and max binary operators, factored together. The minmax.*
-- operators take "this_op" and "opposite_op" as additional
-- parameters; the former contains the current binary operator (min
-- for min, max for max); the later contains the dual operator, to
-- implement contravariance.
local minmax = { }

-- Binary min/max for expression types.
function minmax.te(this_op, opposite_op, a, b)
    local a2s = require 'metalua.compiler.ast_to_src'
    printf ("%s(%s, %s)", this_op.name, a2s(a), a2s(b))

    if eq.te(a, b) then return a end
    match a, b with
    | `TFunction{ pa, ra }, `TFunction{ pb, rb } ->
        local pc = opposite_op.tebar(pa, pb)
        if not pc then return false end
        local rc = this_op.tebar(ra, rb)
        if not rc then return false
        else return `TFunction{ pc, rc } end
    | `TTable{ def_a, pairs_a }, `TTable{ def_b, pairs_b } ->
        local def_c = this_op.tf(def_a, def_b)
        if not def_c then return false end
        local pairs_c = { }
        for tf_a, tf_b, k in field_pairs(a, b) do
            local tf_c = this_op.tf(tf_a, tf_b)
            if not tf_c then return false
            elseif not eq.tf(tf_c, def_c) then
                table.insert(pairs_c, `TPair{ k, tf_c})
            end
        end
        return `TTable{ def_c, pairs_c }
    | _, _ -> return false -- absorbing element instead?
    end
end

-- Binary min/max for expression sequence types.
function minmax.tebar(this_op, opposite_op, tebar1, tebar2)
    if tebar1.tag or tebar2.tag then return false end
    local n = math.max(#tebar1, #tebar2)
    local r = { }
    for i=1, n do
        local ta = tebar1[i] or `TId 'nil'
        local tb = tebar2[i] or `TId 'nil'
        local tc = this_op.te(ta, tb)
        if not tc then return false end
        r[i]=tc
    end
    -- Remove useless nils at end of sequence
    while(r[n].tag=='TId' and r[n][1]=='nil') do
        table.remove(r); n=n-1
    end
    return r
end

-- Binary min/max for field types.
function minmax.tf(this_op, opposite_op, tf1, tf2)
    match tf1, tf2 with
    | `TField, `TField -> return tf1
    | `TField, tf | tf, `TField ->
        return this_op.name == 'min' and tf or `TField
    | `TVar{te1}, `TVar{te2} | `TCurrently{te1}, `TCurrently{te2} ->
        if eq.te(te1, te2) then return tf1 else return false end
    | `TConst{te1}, `TConst{te2} ->
        local te = this_op.te(te1, te2)
        if te then return `TConst{ te } else return false end
    | `TVar{ te1 }, `TConst{ te2 } | `TConst{ te2 }, `TVar{ te1 } ->
        local te = this_op.te(te1, te2)
        if not te then return false end
        local tag = this_op.name == 'min' and 'TVar' or 'TConst'
        return { tag=tag; te }
    | _, _ -> return false
    end
end


-- Create separate min and max operator families from minmax
local min, max = { }, { }
local min2 = { name='min' }
local max2 = { name='max' }
for _, k in ipairs{ 'te', 'tf', 'tebar', 'ts' } do
    min[k] = |...| minmax[k] (min, max, ...)
    max[k] = |...| minmax[k] (max, min, ...)
end

-- Substitutes occurences of `TId and `TIdbar with
-- their name's counterpart in sigma the substitution table.
-- Example: subst(`Op{ 'add', `TId 'x', `TId 'y' }, { x=`String "FOO" })
-- ==> `Op{ 'add', `String "FOO", `TId 'y' }
local function subst(term, sigma)
    checks('!', 'table')
    if type(term)=='table'
    and (term.tag=='TId' or term.tag=='TIdbar') then
        local new_subterm = sigma[term[1]]
        return new_subterm or term
    end
    local changed, result = false
    for i, item in ipairs(where) do
        local new_item = subst(item, sigma)
        changed = changed or item==new_item
        result[i] = new_item
    end
    return changed and result or where
end

return { eq=eq, min=min, max=max, subst=subst }