-{ extension 'match' }

cmp = require 'tilo.compare'
a2s = require 'metalua.compiler.ast_to_src'
new_constraint = require 'tilo.constraint'

function log(mod, level, fmt, ...)
    local args = {...}
    for k, v in pairs(args) do 
        if type(v)=='table' then args[k]=table.tostring(v) end
    end
    local msg = string.format(fmt, unpack(args))
    printf("[%s]\t%s", mod, msg)
end

GAMMA = { }
GAMMA.__index = GAMMA
GAMMA.__type  = 'gamma'

-- Checks whether a value of type `tf_r` can be held in a field of
-- type `tf_l`.
function GAMMA :accept(tf_l, tf_r)
    checks('gamma', 'tf', 'tf')
    log('GAMMA', 'DEBUG', "%s |> %s", a2s(tf_l), a2s(tf_r))
    match tf_l, tf_r with
    | `TField, _ -> -- pass
    | { tag=_, te_l }, `TJust{ te_r } -> -- recursively compare fields
        match te_l, te_r with
        | `TTable{...}, `TTable{...} ->
            for tf_l2, tf_r2 in field_pairs(te_l, te_r) do
                self :accept(tf_l2, tf_r2)
            end
        | _, _ -> self :sub_te(te_r, te_l)
        end
    | `TConst{ te_l }, `TConst{ te_r } -> self :sub_te(te_r, te_l)
    | `TVar{ te_l }, `TVar{ te_r } -> self :eq_te(te_r, te_l)
    | _, _ ->  type_error('tf', tf_l, '|>', tf_r)
    end
end

-- Used by:
-- * `tebar_to_te` to cut first `te` from `tebar` variables
function GAMMA :eq_tebar(tebar1, tebar2)
    checks('gamma', 'tebar', 'tebar')
    match tebar1, tebar2 with
    | `TIdbar{ name }, `TIdbar{ name } -> -- pass
    | `TIdbar{ name }, tebar | tebar, `TIdbar{ name } ->
        self.tebar.eq :add(name, tebar)
    | `TDynbar, _  | _, `TDynbar -> -- pass
    | `TCatbar, _ | _, `TCatbar -> error "not implemented"
    | _, _ if tebar1.tag==nil and tebar2.tag==nil ->
        local n = math.max(#tebar1, #tebar2)
        for i=1,n do
            gamma :eq_te(tebar1[i] or `TId "nil", tebar2[i] or `TId "nil")
        end
    end
end

-- Used by:
-- * `typeof.Annot`, to check that the annotation is a weakening
function GAMMA :sub_ts(ts1, ts2)
    checks('gamma', 'ts', 'ts')
    match ts1, ts2 with
    | `TPass, `TPass -> return nil
    | `TReturn{ teb1 }, `TReturn{ teb2 } -> self :sub_tebar(teb1, teb2)
    | _, _ -> type_error('ts', ts1, '<:', ts2)
    end
end

-- Used by:
-- * `typeof.Call`, to decompose a `TId` into a `TFunction`
-- * `typeof.SetIndex`, for TVar <: [field; k:var te]
-- * `assign`, to check that TVar types don't change
function GAMMA :eq_te(te1, te2)
    checks('gamma', 'te', 'te')
    match te1, te2 with
    | `TDyn, _ | _, `TDyn -> -- pass
    | `TId{ name }, `TId{ name } -> -- pass
    | `TId{ n1 }, `TId{ n2 } -> -- n1 ~= n2
        local p1, p2 = self.prim_types[n1], self.prim_types[n2]
        if p1 and p2 then  type_error ('te', te1, '=', te2)
        elseif p1 and not p2 then  self.te.eq :add (n2, te1)
        else self.eq :add (n1, te2) end
    | `TId{ name }, te | te, `TId{ name } ->
        if self.prim_types[name] then type_error ('te', te1, '=', te2)
        else self.te.eq :add(name, te) end
    | `TTable{...}, `TTable{...} ->
        for tf1, tf2 in field_pairs(te1, te2) do
            self :eq_tf (tf1, tf2)
        end
    | _, _ -> type_error ('te', te1, '=', te2)
    end
end


-- Used by:
-- currently nobody; might later prove need for some variants
-- of `typeof.Call` where we know almost nothing about args type.
-- TODO: get rid of this?
function GAMMA :sub_tebar(tebar1, tebar2)
    checks('gamma', 'tebar', 'tebar')
    match tebar1, tebar2 with
    | `TDynbar, _ | _, `TDynbar -> -- pass
    | `TIdbar{ name }, `TIdbar{ name } -> -- pass
    | _, _ if tebar1.tag==nil and tebar2.tag==nil ->
    --| {tag=nil}, {tag=nil} -> --bug in match?!
        for i=1, math.max(#tebar1, #tebar2) do
            local te1 = tebar1[i] or `TId 'nil'
            local te2 = tebar2[i] or `TId 'nil'
            self :sub_te(te1, te2)
        end
    | `TIdbar{ name }, tebar ->
        self.tebar.sub_pos :add(name, tebar)
    | tebar, `TIdbar{ name } ->
        self.tebar.sub_new :add(name, tebar)
    | `TCatbar{ car, cdr }, _ | _, `TCatbar{ car, cdr} ->
        error "not implemented"
    end
end

-- Used by: 
-- * `typeof.Index`, for TVar <: [field; k:const v]
-- * `typeof.SetIndex`, when table is a TId, to check new value type compat
-- * `typeof.Set`, to check compat between new var value with annotation
function GAMMA :sub_te(te1, te2)
    checks('gamma', 'te', 'te')
    match te1, te2 with
    | `TDyn{...}, _ | _, `TDyn{...} -> -- pass
    | `TId{ name }, `TId{ name } -> -- pass
    | `TId{ name }, te if not self.prim_types[name]->
        if te.tag=='TId' and self.prim_types[te[1]]
        then self.te.eq :add (name, te) -- `x<:prim` only possible if `x=prim`
        else self.te.sub_pos :add(name, te) end
    | `TId{ a }, `TId{ b } if self.prim_types[a] and self.prim_types[b] ->
        type_error('te', te1, '<:', te2)
    | te, `TId{ name } ->
        self.te.sub_neg :add(name, te)
    | `TFunction{ args1, res1 }, `TFunction{ args2, res2 } ->
        for i=1, math.max(#args1, #args2) do
            local arg1 = args1[i] or `TCurrently{ `TId 'nil' }
            local arg2 = args2[i] or `TCurrently{ `TId 'nil' }
            self :sub_te(arg2, arg1)
        end
        self :sub_tebar(res1, res2)
    | `TTable{ def1, pairs1 }, `TTable{ def2, pairs2 } ->
        local tf_pairs = field_pairs(te1, te2)
        for _, tf_pair in ipairs(tf_pairs) do
            local tf1, tf2 = unpack(tf_pair)
            self :sub_tf (tf1, tf2)
        end
    | _, _ -> type_error('te', te1, "<:", te2)
    end
end

-- Used by:
-- * GAMMA :sub_te for tables
function GAMMA :sub_tf(tf1, tf2)
    checks('gamma', 'tf', 'tf')
    match tf1, tf2 with
    | `TCurrently{ te1 }, `TCurrently{ te2 } | `TVar{ te1 }, `TVar{ te2 } -> 
        self :eq_te(te1, te2)
    | `TVar{ te1 }, `TConst{ te2 } | `TConst{ te1 }, `TConst{ te2 } ->
       self :sub_te(te1, te2)
    | _, `TField -> -- pass
    | _, _ -> type_error('tf', tf1, "<:", tf2)
    end
end


-- Returns type associated with variable, in_this_frame
-- Used by:
-- * typeof.Id 
function GAMMA :get_var_tf (var_name)
    checks('gamma', 'string')
    local cell = self.var_types[var_name]
    if not cell then error ("Unknown var "..var_name) end
    if cell.frame == self.current_frame then return cell.type
    elseif cell.type.tag=='TCurrently' then return `TField
    else return cell.type end
end

function GAMMA :get_var_te (var_name)
    checks('gamma', 'string')
    local tf = self :get_var_tf (var_name)
    return tf[1] or error "Can't access var content"
end

function GAMMA :new_var (var_name, tf)
    checks('gamma', 'string', 'tf')
    if self.var_types[var_name] then
        error("Variable shadowing, please alphs-rename")
    end
    self.var_types[var_name] = { type=tf, frame=self.current_frame }
end

-- Must elapse when leaving frame,
-- and must know if it's declared in the top-most frame
-- Used by:
-- * typeof.Local, to set new variables to nil
-- * typeof.Function, to create function param types
-- * typeof.Set, to update a variable's type
function GAMMA :set_var_type (var_name, tf)
    checks('gamma', 'string', 'tf')
    local cell = self.var_types[var_name] 
    if not cell then
        error ("Unknown var "..var_name)
    end
    log('GAMMA', 'DEBUG', "V:  %s: %s", var_name, a2s(tf))
    cell.type = tf
end

function GAMMA :set_sharp (var_name)
    checks('gamma', 'string')
    if self.prim_types[var_name] then return end
    self.te.sharp[var_name] = true
    log('GAMMA', 'DEBUG', "#:  %s is non-linear", var_name)
end

frame_idx = 1

-- Used by:
-- * typeof.Function, to create a new frame
function GAMMA :enter_frame()
    table.insert(self.stacked_frames, self.current_frame)
    frame_idx = frame_idx + 1
    self.current_frame = frame_idx
end

-- Used by:
-- * typeof.Function, to leave a frame
function GAMMA :leave_frame()
    self.current_frame = table.remove(self.stacked_frames)
end

function type_error(t, a, op, b)
    checks('string', 'table', 'string', 'table')
    --local a2s=table.tostring
    local msg = string.format("Cannot prove %s %s %s",
                              a2s(a), op, a2s(b))
    error(msg)
end

function GAMMA :tostring()

    local r = { "Gamma:" }
    local function acc(...) 
        local line = table.concat{...}
        if line ~= '' then table.insert(r, line) end
    end

    for _, k in ipairs{ 
        self.te.eq, self.te.sub_pos, self.te.sub_neg,
        self.tebar.eq,  self.tebar.sub_pos, self.tebar.sub_neg } do
        acc(k :tostring())
    end
    if next(self.te.sharp) then
        local sharps = { }
        for v, _ in pairs(self.te.sharp) do table.insert(sharps, v) end
        table.sort(sharps)
        acc('  non-linear variable types: ', table.concat(sharps, ', '))
    end
    for name, cell in pairs(self.var_types) do
        acc ('  ', name, ': ', a2s(cell.type))
    end
    return table.concat(r, '\n')
end

function GAMMA :close()
    -- Check that upper bounds are indeed bigger than lower bounds
    for v1 in self.te.sub_pos :get_vars() do
        local vars1, bound1 = self.te.sub_pos :get_content(v1)
        local vars2, bound2 = self.te.sub_neg :get_content(v1)
        if bound1 and bound2 then self :sub_te(bound2, bound1) end
    end
    for v1 in self.tebar.sub_pos :get_vars() do
        local vars1, bound1 = self.tebar.sub_pos :get_content(v1)
        local vars2, bound2 = self.tebar.sub_neg :get_content(v1)
        if bound1 and bound2 then self :sub_tebar(bound2, bound1) end
    end
    -- TODO: transform var/var inequalities into equalities
end

function GAMMA :simplify(t)
    checks('gamma', 'te|tf|ts')
    match t with
    | `TId{ name } -> 
        local vars1, bound1 = self.tebar.sub_pos :get_content(v1)
        local vars2, bound2 = self.tebar.sub_neg :get_content(v1)
        if bound1 and bound2 then self :sub_tebar(bound2, bound1) end
    end
end

--- Empty environmnent constructor
function gamma_new()
    local self = {
        prim_types = { number=1, string=1, boolean=1, ['nil']=1 },
        stacked_frames = { },
        current_frame = 1,
        var_types = { },
        te = {
            sharp = { },
            eq      = new_constraint('TE', '=',  cmp.eq.te),
            sub_pos = new_constraint('TE', '<:', cmp.min.te),
            sub_neg = new_constraint('TE', ':>', cmp.max.te) },
        tebar = {
            eq      = new_constraint('TEBAR', '=',  cmp.eq.tebar),
            sub_pos = new_constraint('TEBAR', '<:', cmp.min.tebar),
            sub_neg = new_constraint('TEBAR', ':>', cmp.max.tebar) } }
    return setmetatable(self, GAMMA)
end

