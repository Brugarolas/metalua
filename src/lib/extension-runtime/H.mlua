require 'walk.id'
-{ extension 'log' }

H = |hcfg| function (ast)
   assert(type(ast)=='table', "hygienizer(cfg)(ast)")

   -- Get and parse args:
   -- ast        :: ast to parse
   -- ast_kind   :: string
   -- free_vars  :: old_name -> new_name for free variables
   -- bound_vars :: binder -> old_name -> new_name for bound variables
   -- keep       :: var_name -> boolean
   -- alpha      :: `Local statement carrying original free vars alpha convs
   -- h_inside, h_outside :: booleans
   local local_renames, ast_kind, bound_vars, 
         free_vars, keep, alpha, h_inside, h_outside do
      if not hcfg then hcfg = { } end
      ast_kind   = hcfg.kind or 'guess'
      local side = hcfg.side
      h_inside   = not side or side=='inside'  or side=='both'
      h_outside  = not side or side=='outside' or side=='both'
      if h_inside  then local_renames, bound_vars = { }, { } end
      if h_outside then free_vars  = { } end

      -- kept variables must be in keys, not in values:
      keep = hcfg.keep or { }
      if type(keep)=='string' then keep = { [keep] = 1 }
      elseif #keep>0 then keep = table.transpose(keep) end
      if h_outside then
         -- extend an existing alpha conversion scheme
         alpha = hcfg.alpha or `Local{ { }, { } }
         if #alpha==0 then alpha <- `Local{ { }, { } } end
         local new, old = unpack(alpha)
         assert (#new==#old, "Invalid alpha list")
         for i = 1, #new do
            assert (old[i].tag=='Id' and #old[i]==1, "Invalid lhs in alpha list")
            assert (new[i].tag=='Id' and #new[i]==1, "Invalid rhs in alpha list")
            free_vars[old[i][1]] = new[i][1]
         end
      end
   end

   -- Config for the id walker
   local wcfg = { expr = { }, stat = { }, id = { } }

   if h_outside then
      -- Rename free variables that are not supposed to be captured.
      -- An old_name -> new_name dictionary is kept in free_vars.
      function wcfg.id.free (id)
         local old_name = id[1]
         if keep[old_name] then return end
         local new_name = free_vars[old_name]
         if not new_name then
            new_name = mlp.gensym('X$'..old_name)
            free_vars[old_name] = new_name
            table.insert(alpha[1], `Id{new_name})
            table.insert(alpha[2], `Id{old_name})
         end
         id[1] = new_name
      end
   end
   
   if h_inside then
      local_renames = { }
      
      -- Rename a binding `Id,
      -- Keep a binder -> old_name -> new_name distionary in bound_vars.
      function wcfg.binder (id, binder)
         if id.h_boundary then return end
         local old_name = id[1]
         local binder_table = bound_vars[binder]
         if not binder_table then
            binder_table = { }
            bound_vars[binder] = binder_table
         end
         local new_name = mlp.gensym('L$'..old_name)[1]
         binder_table[old_name] = new_name
         local_renames[id] = new_name
      end
      -- Rename a bound variable,
      -- its new name should already be in bound_vars.
      function wcfg.id.bound (id, binder)
         if id.h_boundary then return end
         local old_name = id[1]
         local new_name = bound_vars[binder][old_name]
         --$log(bound_vars[binder])
         assert(new_name, "no alpha conversion for a bound var?!")
         local_renames[id] = new_name
      end
   end

   -- Don't traverse trees spliced into the quote
   local cut_boundaries = |x| x.h_boundary and 'break' or nil
   wcfg.stat.down, wcfg.expr.down = cut_boundaries, cut_boundaries

   -- The walker's config is ready, let's go.
   -- After that, ids are renamed in ast, free_vars and bound_vars are set.
   walk_id[ast_kind](wcfg, ast)

   -- Apply local name changes
   for id, new_name in pairs(local_renames) do id[1] = new_name end
      
   return ast, alpha
end

