----------------------------------------------------------------------
-- Metalua samples:  $Id$
--
-- Summary: AST --> source code converter.
--
----------------------------------------------------------------------
--
-- Copyright (c) 2006, Fabien Fleutot <metalua@gmail.com>.
--
-- This software is released under the MIT Licence, see licence.txt
-- for details.
--
--------------------------------------------------------------------------------
--
-- This sample takes an AST and converts it into a source string.
-- Once correctly polished, this will be a valuable tool to debug
-- hairy macros that generate hard to read AST.
--
--------------------------------------------------------------------------------
--
-- TODO:
-- - handle precedence correctly. Currently, expressions requiring parentheses
--   might or might not work.
--
--------------------------------------------------------------------------------

-- Runtime warning
print [[Warning: you are using srcdump, an AST -> source converter, which is not correct yet wrt e.g. precedence and parentheses. Expect nasty bugs.]]
-- Compile-time warning
-{ print [[Warning: you are using srcdump, an AST -> source converter, which is not correct yet wrt e.g. precedence and parentheses. Expect nasty bugs.]] }

-{ extension 'match' }

local opnames = {
 __add    = "+",    __sub    = "-",
 __mul    = "*",    __div    = "/",
 __mod    = "%",    __pow    = "^",
 __concat = "..",   __eq     = "==",
 __lt     = "<",    __le     = "<=",
 __and    = "and",  __or     = "or", 
 __not    = "not ", __len    = "#" }

local keywords = {
    "and", "break", "do", "else", "elseif",
    "end", "false", "for", "function", "if",
    "in", "local", "nil", "not", "or", "repeat",
    "return", "then", "true", "until", "while" }

function dump (ast)
   local indent_offset = 0
   local accumulator = { }
   local function indent() indent_offset += 1 end
   local function dedent() indent_offset -= 1 end
   local function acc(...) table.insert(accumulator, string.format(...)) end
   local function newline() acc "\n"; acc (string.rep("   ", indent_offset)) end
   local is_ident = |x| string.strmatch(x, "^[%a_][%w_]*$") and not keywords[x]

   local parse_expr, parse_stat, parse_body, parse_funcdef, 
         parse_id, parse_list, parse_block

   function parse_expr (ast)
      match ast with
      | `Nil       -> acc "nil"
      | `Dots      -> acc "..."
      | `True      -> acc "true"
      | `False     -> acc "false"
      | `Number{x} -> acc ("%i", x)
      | `String{x} -> acc ("%q", x)
      | `Id{ x }   -> parse_id (x)
      | `Paren{ a }  -> acc "("; parse_expr (a); acc ")"

      | `Op{ op, a, b } ->
         -- FIXME: handle precedence and parentheses around [a] and [b]
         parse_expr (a); acc (" %s ", opnames[op]); parse_expr (b)

      | `Op{ op, a } ->
         -- FIXME: handle precedence and parentheses around [a]
         acc ("%s", opnames[op]); parse_expr (a)

      | `Call{ f, `String{ _ } } | `Call{ f, `Table{ ... } } ->
         -- FIXME: handle precedence and parentheses around [f]
         parse_expr (f); acc " "; parse_expr (ast[2])

      | `Call{ f, ... } ->
         -- FIXME: handle precedence and parentheses around [f]
         parse_expr (f)
         acc " ("; parse_list (parse_expr, ast, ", ", 2); acc ")"

      | `Method{ f, name, ... } ->
         --CAVEAT: handle precedence and parentheses around [f]
         parse_expr (f)
         acc ":"; parse_id (name); acc " ("
         parse_list (parse_expr, ast, ", ", 3)
         acc ")"

      | `Function{ params, body } ->
         acc "function "; parse_funcdef (params, body)

      | `Index{ t, `String{ k } } if is_ident(k) ->
         --CAVEAT: handle precedence and parentheses around [t]
         parse_expr (t); acc (".%s", k)

      | `Index{ t,  k } ->
         --CAVEAT: handle precedence and parentheses around [t]
         parse_expr (t); acc "["; parse_expr (k); acc "]"
       
      | `Table{  } -> acc "{ }"

      | `Table{ ... } ->
         acc "{"
         indent(); newline()
         for i = 1, #ast do
            match ast[i] with
            | `Pair{ `String{ k }, v } if is_ident (k)-> 
               acc ("%s = ", k); parse_expr (v)
            | `Pair{ k, v } -> 
               acc "["; parse_expr (k); acc "] = "; parse_expr (v)
            | v -> 
               parse_expr (v)
            end
            if i < #ast then acc ";"; newline() end
         end
         acc " }"
         dedent()

      | `Stat{ b, e }  ->
         acc "-{ `Stat{ +{ block:";
         parse_block (b)
         acc "}, +{ "
         parse_expr (e)
         acc " } } }"

      | _ -> error ("Can't sourcedump expression " .. ast.tag)
      end
   end

   function parse_funcdef (params, body)
      acc " ("; parse_list (parse_expr, params, ", "); acc ")"
      parse_block (body)
      acc "end"
   end

   function parse_block (ast)
      indent(); newline()
      for i = 1, #ast do
         parse_stat (ast[i])
         if i == #ast then dedent() end
         newline()
      end
   end

   function parse_id (ast)
      if type (ast) == "table" then ast = ast[1] end
      assert (type(ast) == "string", "Invalid identifier")
      if is_ident (ast) then acc ("%s", ast)
      else acc ("-{`Id %q}", ast) end -- FIXME: might require parens in some cases
   end

   function parse_list (parser, list, sep, start, finish)
      for i = start or 1, finish or #list do
         parser (list[i])
         if i<#list then acc ("%s", sep) end
      end
   end

   function parse_stat (ast)
      match ast with
      | `Do{ ... } -> acc "do"; parse_block (ast); acc "end"

      | `While{ cond, body } ->
         acc "while "; parse_expr (cond); acc " do"
         parse_block (body)
         acc "end"

      | `Repeat{ body, cond } ->
         acc "repeat"
         parse_block (body)
         acc "until "; parse_expr (cond)

      | `If{ ... } ->
         for i = 1, #ast-1, 2 do
            if i==1 then acc "if " else acc "elseif " end
            parse_expr (ast[i])
            acc " then"
            parse_block (ast[i+1])
         end
         if #ast % 2 == 1 then
            acc "else"
            parse_block (ast[#ast])
         end
         acc "end"        

      | `Fornum{ `Id{ var }, a, b, c, body } ->
         acc "for "; parse_id (var); acc " = "
         parse_expr (a); acc ", "
         parse_expr (b); acc ", "
         parse_expr (c); acc " do"
         parse_block (body)
         acc "end"

      | `Fornum{ `Id{ var }, a, b, body } ->
         acc "for "; parse_id (var); acc " = "
         parse_expr (a); acc ", "
         parse_expr (b); acc " do"
         parse_block (body)
         acc "end"

      | `Forin{ varlist, vallist, body } ->
         acc "for "; parse_list (parse_id, varlist, ", "); acc " = "
         parse_list (parse_expr, vallist, ", ")
         acc " do"
         parse_block (body)
         acc "end"

      | `Local{ lhs, { } } ->
         acc "local "
         parse_list (parse_id, lhs, ", ")

      | `Local{ lhs, rhs } ->
         acc "local "
         parse_list (parse_id, lhs, ", ")
         acc " = "
         parse_list (parse_expr, rhs, ", ")

      | `Localrec{ { `Id{ name } }, { `Function{ params, body } } } ->
         acc "local function "; parse_id (name); parse_funcdef (params, body)

      | `Set{ { `Index{ obj, `String{ name } } }, 
              { `Function{ { `Id "self", ... }, body } } } ->
         local params = ast[2][1][1]
         acc "function "
         parse_expr (obj); acc (":%s ", name); parse_funcdef (params, body)
         
      | `Set{ { lhs }, { `Function{ params, body } } } ->
         acc "function "; parse_expr (lhs); parse_funcdef (params, body)

      | `Set{ lhs, rhs } -> 
         parse_list (parse_expr, lhs, ", ")
         acc " = "
         parse_list (parse_expr, rhs, ", ")

      | `Return{ ... } -> acc "return "; parse_list (parse_expr, ast, ", ")
      | `Goto{ x } -> acc "-{ `Goto{ +{ "; parse_expr (x); acc " } } }" 
      | `Label{ x } -> acc "-{ `Label{ +{"; parse_expr (x); acc " } } }" 

      | { ... } if not ast.tag -> 
        for i = 1, #ast do
           parse_stat (ast[i])
           if i<#ast then newline() end
        end
     
      | `Break         -> acc "break"
      | `Call{ ... }   -> parse_expr (ast)
      | `Invoke{ ... } -> parse_expr (ast)
      | _              -> error ("Can't sourcedump statement " .. ast.tag)
      end
   end
   
   local expr_tags = { 
      Nil = 1, Dots = 1, True = 1, False = 1, Number = 1, String = 1, 
      Function = 1, Table = 1, Call = 1, Method = 1, Id = 1, Index = 1,
      Op = 1 }

   if expr_tags [ast.tag] then parse_expr (ast) else parse_stat (ast) end
   return table.concat (accumulator)
end