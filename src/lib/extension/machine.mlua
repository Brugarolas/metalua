-{ extension 'match' }

require 'strict'

--[===[ 
-- The following concrete syntax: --
machine
   state S1
      when enter, update do foo() end
      when enter do gnu() end
      when exit do bar() end
      on msg1 -> S1
      on msg2 -> S2
end

-- Will be translated into the following config: --
{ states = { S1 = { name = "S1",
                    actions = { enter  = { 1, 2 }, 
                                update = { 1 },
                                exit   = { 2 } }, 
                    transitions = { msg1 = "S1",
                                    msg2 = "S2" } } },
  action_code = { [1] = function() foo() end,
                  [2] = function() gnu() end } }
                  [3] = function() bar() end } }
--]===]

----------------------------------------------------------------------
-- Definitions:
-- * an _event_ is relative to a state. It can be:
--   + 'enter',  when we go in that state
--   + 'update', when we re-select the state we were already in.
--   + 'exit',   when we leave the state
-- * an _action_ is a function, associated with a state and an event.
-- * a _message_ is a token sent to the state machine, which determines
--   the next state that will be selected.
-- * an _entry_ is a line of data, attached to a string, as produced
--   by the parser. This builder's main purpose is to turn such
--   entries into a proper machine config.
----------------------------------------------------------------------
local function machine_builder (x)
   
   --print "Building machine"
   local declared_states, used_states = { }, { }
   local actions = { }
   local last_action_idx = 0

   ---------------------------------------------------------
   -- First pass: gather the description of actions and
   -- transitions, sorted by affected states, in
   -- declared_states. state configs are indexed by name,
   -- and have fields:
   -- * name, their name;
   -- * code, an event -> function id hashtable
   -- * trans, a msg -> new state hashtable
   --
   -- Since actions can be bound to several events, they're
   -- associated with a unique index that will be used
   -- instead of the function itself, to prevent useless
   -- duplication. All those names are collected in the
   -- action_code hashtable, in the state's config.
   --
   -- This pass checks that there's no duplicate responses to 
   -- messages or events.
   ---------------------------------------------------------
   for state in ivalues (x[1]) do
      local state_id, state_entries = unpack(state)
      local state_name = state_id[1]
      --printf("  Building state %s, pass #1", state_name)
      local state_cfg = declared_states[state_name]
      if not state_cfg then
         -- This state has no entry, create one.
         state_cfg = { name        = state_name, 
                       transitions = { },
                       actions     = { enter  = `Table{ },
                                       update = `Table{ }, 
                                       exit   = `Table{ } } }
         declared_states[state_name] = state_cfg
      end

      for entry in ivalues (state_entries) do
         match entry with
         -----------------------------------------
         -- "when <id_list> do <block> end"
         -----------------------------------------
         | `When{ events, code } -> 
            
            -- Set action_idx->action_code in cfg.action_code
            last_action_idx += 1
            local action_idx = last_action_idx
            actions [action_idx] = code
            
            -- Set ev_name->action_idx pairs in cfg[state].actions
            for ev_id in ivalues (events) do
               local ev_name = ev_id[1]
               --printf("    Parsing event %s", ev_name)
               local actions_list = state_cfg.actions[ev_name]
               if not actions_list then
                  error ("Invalid event "..ev_name.." in state "..state_name)
               else
                  table.insert(actions_list, `Number{action_idx})
               end
            end
         -----------------------------------------
         -- "on <msg_id> -> <state>"
         -----------------------------------------
         | `On{ messages, target_state } ->

            -- Set msg_name->ttarget_name pairs in cfg[state].transitions
            for msg_id in ivalues (messages) do
               local msg_name, target_name = msg_id[1], target_state[1]
               --printf("    Parsing transition %s -> %s", msg_name, target_name)
               if state_cfg.actions[msg_name] then 
                  error("Two transitions triggered by message "..msg_name..
                        " in state "..state_name)
               end
               -- We'll later check that all target states exist.
               used_states[target_name] = { msg=msg_name, src_state=state_name }
               state_cfg.transitions[msg_name] = target_name
            end -- for each msg
         end -- match entry
      end -- for each entry
   end -- for each state

   ---------------------------------------------------------
   -- Check that every target state exists.
   ---------------------------------------------------------
   for a, b in pairs (used_states) do 
      if not declared_states[a] then 
         error ("State "..b.src_state.." tries to go to inexistant state "..a..
                " when receiving message "..b.msg)
      end
   end

   local states_ast = `Table{ }

   ---------------------------------------------------------
   -- 2nd pass: turn state configs into AST.
   ---------------------------------------------------------
   for state_cfg in values (declared_states) do
      --printf("  Pass #2 for state %s", state_cfg.name)

      -- Generate action name -> action code_idx hashtable.
      local actions_entry = `Table{ }
      for ev_name, action_indexes in pairs (state_cfg.actions) do
         table.insert (actions_entry, 
                       `Pair{ `String{ ev_name }, action_indexes })
      end
      -- Generate msg -> target state hastable.
      local transitions_entry = `Table{ }
      for msg_name, target_state in pairs (state_cfg.transitions) do
         table.insert (transitions_entry, 
                       `Pair{ `String{ msg_name }, `String{ target_state } })
      end
      -- Generate state config structure
      local state_ast =
         `Table{ `Pair{ `String 'actions',     actions_entry },
                 `Pair{ `String 'transitions', transitions_entry } } 
      -- Register state structure.
      table.insert (states_ast, `Pair{ `String{ state_cfg.name }, state_ast })              
   end

   ---------------------------------------------------------
   -- register the action name -> action code hashtable
   ---------------------------------------------------------
   local action_code_ast = `Table{ }
   for action_idx, action_code in pairs (actions) do
      table.insert (action_code_ast, `Pair{ `Number{ action_idx },
                                            `Function{ { }, action_code } })
   end

   local cfg_ast = +{ { action_code = -{action_code_ast},
                        states      = -{states_ast} } }

   return +{stat: Machine:new(-{cfg_ast})}
end

local machine_entry = gg.multisequence{
   { 'when', mlp.id_list, 'do', mlp.block, 'end', builder = 'When' },
   { 'on', mlp.id_list, '->', mlp.id, builder = 'On' },
   { 'do', mlp.block, 'end', builder =
     |x| `When{ { `Id 'enter', `Id 'update' }, x[1] } } }

local machine_state = gg.sequence{ 
   'state', mlp.id, 
   gg.list{ machine_entry, terminators = { 'state', 'end' } } }

local machine_content = gg.sequence { name = 'State machine constructor',
   gg.list{ machine_state, terminators = 'end' },
   builder = machine_builder }

mlp.lexer:add{ 'machine', 'state', 'when', 'on', '->' }
mlp.expr:add{  'machine', machine_content, 'end', builder = |x|x[1] }
mlp.stat:add{  'machine', mlp.expr, machine_content, 'end',
   builder = |x| `Set{ {x[1]}, {x[2]} } }

return +{ require 'extension.machine-runtime' }