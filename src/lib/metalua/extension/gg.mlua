--------------------------------------------------------------------------------
-- Syntax supported:
--
-- * parsers are declared, in Lua, within << ... >>
--
-- * sequence parsers are build with `,':
--   << "do", mlp.block, "end" >>
--      ==> gg.sequence{ "do", mlp.block, "end" }
--
-- * multisequence parsers are built with `||':
--   <<  "do", mlp.block, "end" || "while", mlp.expr, "do", mlp.block, "end" >>
--       ==> gg.multisequence{ 
--              gg.sequence{ "do", mlp.block, "end" },
--              gg.sequence{ "while", mlp.expr, "do", mlp.block, "end" } }
--
-- * lists are declared with a prefix `repeat'. They can be suffixed
--   with `until "kw_1" or "kw_2" or ... or "kw_n"'  for terminators, or
--   with `while "kw_1" or "kw_2" or ... or "kw_n"'  for separators.
--   << repeat mlp.expr while "," >>
--      ==> gg.list{ mlp.expr, separators={ "," } }
--   << "{", repeat pair_or_expr while "," or ";" until "}", "}" >>
--      ==> gg.sequence{ "{",
--             gg.list{ pair_or_expr, separators={ ",", ";" },
--                                    terminators={ "}" } }, "}" }
--
-- * onkeyword triggered parsers are denoted by a `=>' between the keyword
--   and the parser:
--   << "else" => mlp.block >>
--      ==> gg.onkeyword{ "else", mlp.block }
--
-- * optkeywords are denoted by a suffix `?' (multiple optkeywords aren't
--   supported yet):
--   << ";" ? >>
--      ==> gg.optkeyword{ ";" }
--
-- Moreover, it is possible to capture parts of a parsed tree, and to use it
-- in a builder expression. Capturing a sub-tree is done by prefixing it with
-- an identifier and an `=' sign. Builder expressions are introduced with
-- a `::' infix operator:
--
-- << "while", condition=mlp.expr, "do", body=mlp.block, "end" 
-- :: `While{ condition, body } >>
--    ==> gg.sequence{ "while", mlp.expr, "do", mlp.block, "end",
--           builder = function (it)
--              local condition, body = it[1], it[2]
--              return `While{ condition, body }
--           end }
--
-- Notice that:
--
-- * The link between binders (<identifier> = <parser>) and builders
--   (<parser> :: <expr>) doesn't go through multisequences nor lists.
--   The following is therefore incorrect (and incidentally meaningless):
--
--   << "<%", repeat foo=mlp.expr while ",", "%>" :: foo >>
--
-- * Parentheses are accepted inside parser definitions
--
-- * Lua expressions are also accepted
--
-- * Precedence: the operators, from the lowest to the tightest precedence,
--   are `||', `::', `,', `=>', `=', `?'.
--
-- * In lua expressions, parsers don't require parentheses to be passed as
--   arguments to functions and methods. These are therefore valid expressions:
--
--   x = << "do", mlp.block, "end" >>
--
--   mlp.stat:add << "loop", b=mlp.block, "end" :: +{while true do -{b} end} >>
--
--   table.print << "do", mlp.block, "end" >>
--
--
-- * Since parsers are not function bodies, mutually recursive parsers would
--   be tricky to define. To handle this, two statement syntaxes are
--   declared:
--
--    - `forward <mlp.expr>' promises that a parser will eventually be stored
--      in mlp.expr, which must therefore be a valid left-hand-side expression;
--
--    - `local forward <id>' is the same as `local <id>; forward <id>'.
--
--------------------------------------------------------------------------------

require 'metalua.ast_to_string'

-{ extension 'match' }
-{ extension 'log' }

require 'strict'

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--
-- Abstract syntax -> Lua compiler
--
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- compile() takes a special parser AST, and returns:
--
--  * a Lua AST;
--
--  * a var_name->path table, where the path describes how to extract 
--    a variable's value from a builder
--
-- The latter table is used to build builders out of parsers; each node
-- compiler is in charge of changing and returning the paths as necessary.
--
-- The parser AST grammar is as follows:
--
-- p ::= `Sequence{ p* }
--     | `Multisequence{ `Sequence{ p* } * }
--     | `List{ p, { kw* },  { kw* } }
--     | `Onkeyword{ `Lua{ kw }, p }
--     | `Optkeyword{ kw* }
--     | `Bind{ name, p }
--     | `Lua{ mlp.expr }
--     | `Builder{ p, mlp.expr }
-- 
-- kw ::= `String{ <string> }
--
-- It's generated by the expr_parser defined below.
--
--------------------------------------------------------------------------------

compile = { }; setmetatable (compile, compile)

-- `compile()' dispatches node handling according to the node's tag:
function compile:__call (ast)
   -- $log (ast, 'nohash')
   return self [ast.tag] (self, unpack (ast))
end

function compile:Multisequence (...) 
   local x, openvars = `Table{ }, nil
   for i, p in ipairs{ ... } do
      x[i], openvars = self (p)
      if next (openvars) then
         eprintf ("Warning: lost open variables in a multisequence case")
      end
   end
   return `Call{ +{gg.multisequence}, x }, { } -- binders don't go through.
end

function compile:Sequence(...) 
   local x = `Table{ }
   local openvars = { }
   local j = 0 -- index of the current parser in the sequence's result
   for i, p in ipairs{ ... } do
      local o 
      match p with
      | `Lua{ `String{ keyword }==kw_string } -> x[i], o = kw_string, { }
      | _ -> x[i], o = self (p)
      end
      if x[i].tag ~= 'String' then 
         -- add an index to var paths
         j += 1 
         for var_name, var_accessor in  pairs (o) do
            table.insert (var_accessor, j)
            openvars [var_name] = var_accessor
         end
      else assert (not next(o), "there shouldn't be openvars on a keyword") end
   end
   return `Call{ +{gg.sequence}, x }, openvars
end

function compile:List (p, sep, term)
   local x, o = self (p)
   if next (o) then
      eprintf ("Warning: lost open variables in a list element parser")
   end
   local args = `Table{ x }
   local r = `Call{ +{gg.list}, args }
   local function insert_pair (key, values)
      if values and next(values) then
         values.tag = 'Table'
         table.insert (args, `Pair{ `String{ key }, values })
      end
   end
   insert_pair ('separators', sep)
   insert_pair ('terminators', term)
   return r, { } -- binders don't go through
end

function compile:Onkeyword (kw, p)  
   local x, o = self (p)
   if next (o) then
      -- update accessors
      for var_name, var_accessor in  pairs (o) do
         table.insert (var_accessor, 'optional')
         o [var_name] = var_accessor
      end
   end
   return +{ gg.onkeyword{ -{kw}, -{x} } }, { }
end

function compile:Optkeyword (kw)
   return +{gg.optkeyword {-{ kw }} }, { }
end

function compile:Lua (expr)
   if expr.tag=='String' then 
      return +{ gg.sequence{ -{expr} } }, { }
   else
      return expr, { }
   end
end

function compile:Bind (name, p)
   local x, o = compile (p)
   o [name] = { }
   return x, o
end

-- From a binder path, reconstitute an accessing expression
local function apply_path (path, x)
   match table.remove (path) with
   | 'optional'             -> return +{ -{x} and apply_path (path, -{x}) }
   | n if type(n)=='number' -> return `Index{ apply_path(path, x), `Number{n} }
   | nil                    -> return x
   end
end

function compile:Builder (p, expr)
   local x, o = compile (p)
   
   -- We need the result to accept builders
   match x with
   | +{ gg.optkeyword{ -{...} } } -> error "Optkeyword can't support a builder"
   | +{ gg[ -{name} ]{ -{...} } } -> -- pass
   | _ -> error "This parser can't support a builder"
   end

   -- Build accessors to bound vars
   -- FIXME: only generate an accessor if the variable is used in `expr'
   -- FIXME: -{it} should be gensym'ed
   local vars, accessors = { }, { }
   for var, path in pairs (o)  do
      local accessor = apply_path (path, +{it})
      table.insert (vars, var)
      table.insert (accessors, accessor)
   end
   
   -- Builder function:
   local f = next(vars) 
      and +{ function (it) -{ `Local{ vars, accessors} } return -{expr} end }
      or  +{ || -{expr} }

   -- Insert builder in the AST of the parser argument table:
   table.insert (x[2], `Pair{ +{"builder"}, f })

   return x, { } -- remove binders (their path is not valid anymore)
end

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--
-- Concrete syntax parsers
--
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- list suffixes: ``until <terminators>'' and ``while <separators>''
--------------------------------------------------------------------------------
function list_qualifiers_parser (lx)
   local kw_list = gg.list{ mlp.string, separators = "or" }
   local separators, terminators
   while true do
      match lx:is_keyword (lx:peek()) with
      | "while" if not separators  -> lx:next(); separators  = kw_list (lx)
      | "until" if not terminators -> lx:next(); terminators = kw_list (lx)
      | _  -> return { separators or { }, terminators or { } }
      end
   end
end

-- Forward declaration for self reference
local function _expr_parser (...) return expr_parser (...) end

local function get_lua (ast)
   match ast with
   | `Lua{ x } -> return x
   | _ -> $log(ast, 'nohash'); error "Lua expr expected"
   end
end

--------------------------------------------------------------------------------
-- Main parser expression syntax: This parses the content of << ... >>.
--------------------------------------------------------------------------------
expr_parser = gg.expr{ name = "gg parser",

   primary = gg.multisequence{ 
      { "(", _expr_parser, ")", builder = |x| x[1] },
      { "repeat", _expr_parser, list_qualifiers_parser, 
         builder = |x| `List{ x[1], x[2][1], x[2][2] } },
      { mlp.expr, builder = 'Lua' }
   },
   
   infix = { 
      { "=",      prec=90, builder = |v,_,p| `Bind{ get_lua(v), p } },
      { ",",      prec=50, builder = 'Sequence',      assoc = 'flat' },
      { "|", "|", prec=30, builder = 'Multisequence', assoc = 'flat' },
      { "=>",     prec=70, builder = |k,_,p| `Onkeyword{ get_lua(k), p } }
   }, 

   prefix = { },

   suffix = {
      { "?", prec=100, builder = |k,_| `Optkeyword{ get_lua(k) } },
      { "::", mlp.expr, prec=40, 
         builder = |p,x| `Builder{ p, x[1] } },
   }
}

--------------------------------------------------------------------------------
-- Plug parser expression in metalua, between << ... >>
-- ``myparser = << ... >>''
--------------------------------------------------------------------------------
mlp.expr.primary:add{ "<<", expr_parser, ">>", builder = |x| (compile(x[1])) }

--------------------------------------------------------------------------------
-- Allow parsers as function parameters without parentheses
-- ``function_accepting_parsers << foo, bar >>''
--------------------------------------------------------------------------------
mlp.expr.suffix:add { 
   "<<", expr_parser, ">>", 
   builder = |f, x| `Call{ f, (compile(x[1])) } }

--------------------------------------------------------------------------------
-- Allow parsers as method parameters without parentheses:
-- ``object:method_accepting_parsers << foo, bar >>''
--------------------------------------------------------------------------------
mlp.method_args:add { "<<", expr_parser, ">>", builder = |x| {(compile(x[1]))} }

--------------------------------------------------------------------------------
-- Declare a forward parser (i.e. an eta-expansion of a future parser):
-- ``forward some.parser''
--------------------------------------------------------------------------------
mlp.stat:add { "forward", mlp.expr,
   builder = |x| +{stat: (-{x[1]}) = |...| -{x[1]}(...) } }

--------------------------------------------------------------------------------
-- Declare a forward parser, and simultaneously create a local var for it:
-- ``local forward myparser''
--------------------------------------------------------------------------------
local local_parser = mlp.stat :get "local" [2]
local_parser:add{ "forward", mlp.id,
   builder = |x| +{stat: local function -{x[1]}(...) return -{x[1]}(...) end } }

