-- stuff to support:
-- * gg.sequence
--   << "do", b=mlp.block, "end" ::  b >>
-- * gg.multisequence
--   <<  "do", mlp.block, "end" || "while", mlp.expr, "do", mlp.block, "end" >> 
-- * gg.expr
--   not supported yet
-- * gg.list
--   expr_list = << repeat mlp.expr while "," >>
--   block = << repeat mlp.expr, ? ";" until "end" >>
--   table = << "{", repeat pair while "," or ";", "}" >> 
-- * gg.onkeyword
--   << "else" => mlp.block >>
--   << "if", pairs = repeat mlp.expr, "then", mlp.block while "elseif",
--      last = "else" => block, "end" 
--   :: `If{ table.iflatten (table.insert (pairs, last)) } >> 
-- * optkeyword
--   <<? ";" >>
--
-- Now I also need to bind builders to them. Being able to write x.builder = ...
-- would greatly help. 
--

require 'metalua.ast_to_string'

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- print debug info.
function pdli (x, ...)
   local function dli (x)
      if type(x)=='table' then
         x.lineinfo=nil
         for k, v in pairs(x) do dli(k); dli(v) end
      end
      return x
   end
   return table.tostring(dli(x), ...)
end

pdli = ast_to_string
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------

-{ extension 'match' }

require 'strict'


-- binders  :: parser => varname => (place)*
-- builders :: parser => function quote
binders  = { }
builders = { }

function set_builder (parser, builder_body)
   -- generer le builder: transformer chaque binder en un accesseur,
   -- et fabriquer une fonction.
   local my_binders = binders [parser] or { }
   local my_builder = builders [parser]
   if not my_builder then error "No builder for this parser" end
   local fetch = `Local{ { }, { } }
   for var, place in pairs (my_binders) do
      local a = +{A}
      for e in ivalues (place) do
         -- FIXME: by fixing optkey/onkey, the test could be avoided
         a = +{ -{a} and -{a} [-{`Number{ e }}] }
      end
      table.insert (fetch[1], `Id{ var })
      table.insert (fetch[2], a)
   end
   --FIXME: body peut pas etre juste un Builder
   --if body.tag == 'Builder' then body = compile_builder (body[1]) end
   if fetch[1][1] then 
      my_builder <- +{ function (A) -{fetch} return -{builder_body} end }
   else
      my_builder <- +{ function (A) return -{builder_body} end }
   end
end

-- Build the result of +{ -{parser} :: -{op[1]} }
function builder_builder (parser, op)
   local builder_body = op[1]

   if not gg.is_parser (parser) then
      -- Embed parser in a single-element parser,
      -- so that it can receive a builder.
      local my_builder = +{nil}
      builders [parser] = my_builder
      parser <- +{ gg.sequence { -{ `String{ parser[1] } }, 
                                 builder = -{my_builder} } } 
   end
   set_builder (parser, builder_body)
end

function bind_builder (id, _, parser)
   assert (id.tag=='Id', "identifier expected on left of '='")
   local name = id [1]
   local b = binders [parser] 
   if not b then b = { }; binders [parser] = b end
   b [name] = { }
   return parser
end

function seq_builder (x)
   -- r: resulting parser AST
   -- args: sub-parsers
   -- my_builder == builders[r]: this parser's builder AST
   -- my_binder  == binders [r]: binders in this parser
   local args, my_binders, my_builder, i = `Table{ unpack (x) }, { }, +{nil}, 1
   table.insert (args, `Pair{ +{"builder"}, my_builder })
   local r = +{ gg.sequence (-{args}) } 
   binders  [r] = my_binders
   builders [r] = my_builder

   -- For each non-keyword sub-parser, add the relevant binding
   for _, y in ipairs (args) do      
      if y.tag ~= 'String' then 
         for name, place in pairs (binders [y] or { }) do
            assert (not my_binders [name], "Multiple occurences of binder "..name)
            table.insert (place, i)
            my_binders [name] = place
         end
         i=i+1 -- only increment for non-keywords!
      end
      -- binders [y] = nil -- release binders for sub-parsers
   end
   return r
end

--------------------------------------------------------------------------------
-- Build a multisequence node and its binders:
--
--  * Generate the union list of all bound names in all alternatives
--
--  * Each alternative is a `Sequence{ } and therefore has no builder,
--    generate a builder which returns an array of all the possibly bound
--    variables. If alternatives don't have the same binders, there will
--    be some `nil' values in the array.
--
--  * As a result, the `Multisequence{ } as a whole as a single, clear
--    set of binders, which is published normally, as a `binders[x]'
--    entry.
--
--------------------------------------------------------------------------------
function multi_builder (x)

   -- name_set = smallest common superset of bound vars in alternatives, as a set
   local names_set = { }
   for y in ivalues (x) do
      for name in keys (binders[y] or { }) do all_names [name] = true end
   end

   -- Turn single keywords, into trivial sequences
   for i, alt in ipairs (x) do
      if alt.tag=='String' then 
         --eprintf("Make a sequence from string "..alt[1])
         local my_builder = +{nil}
         builders [alt] = my_builder
         alt <- +{ gg.sequence{ -{ `String{ alt[1] } }, builder = -{my_buidler} } }
      end
   end

   local my_binders = { }

   -- If nothing's exported, avoid useless reformatting
   if next (names_set) then

      -- names_list: names_set converted into a list (arbitrary order)
      local names_list = { }
      for name in keys (names_set) do table.insert (names_list, name) end

      -- Put a builder in each alternative, so that they all present the same
      -- bound vars in the same order.
      for i, alt in ipairs(x) do
         
         --eprintf("MULTIBUILDER ALT #%i: \n%s", i, pdli(alt, 50))
      
         -- Compute the list of missing symbols
         local b, r = binders [alt], `Table{ }
         if b then -- b has some binders, generate a complete name_list
            for j, name in ipairs (names_list) do
               if b[name] then r[j] = `Id{ name } else
                  r[j] = +{nil}
                  eprintf("Warning: symbol "..name..
                          " is not always bound in multisequence")
               end
            end
            set_builder (alt, r)
         else -- no binders for alt, make it build an empty table
            alt.builder = `Builder{ { }, `Table{ } }
         end
      end
      
      -- Every bound var has been handled by the multiseq, give them
      -- their new places.
      for i, var in ipairs (names_list) do
         my_binders [var] = { i }
      end
   end
   
   -- Build up the multisequence call statement
   x.tag = 'Table'
   local my_builder = +{nil}
   table.insert (x, `Pair{ +{"builder"}, my_builder })
   local r = +{ gg.multisequence (-{x}) }
   builders[r] = my_builder
   binders [r] = my_binders
   --eprintf("MULTIBUILDER RESULT: \n%s", pdli(r, 50))
   return r
end

--------------------------------------------------------------------------------
-- * kw: keyword triggering gg.onkeyword
-- * p:  parser triggered by kw
-- The binders in p are kept, they're simply forced to nil if p isn't triggered. 
--------------------------------------------------------------------------------

-- FIXME C'est pas vrai, rien n'est fait pour l'instant avec les binders

function onkey_builder (x)
   local kw, _, p = unpack (x)
--   for name, place in pairs (binders [p] or { }) do
--      table.insert (place, 'maybe')
--   end
   local r = +{ gg.onkeyword{ -{kw}, -{p} } }
   --binders [r], binders [p] = binders [p], nil
   binders [r] = binders [p]
   return r
end

--------------------------------------------------------------------------------
-- builder for lists.
-- * parser is the list elements parser
-- * qualifiers is built by list_qualifiers, it's a list of `Pair{}s,
--   possibly empty, to be appended to the list arguments og +{gg.list()}.
--   Its keys can by +{"terminators"} and/or +{"separators"}.
--------------------------------------------------------------------------------
function list_builder (x)
   local parser, qualifiers = unpack (x) 
   -- Emit a warning if any binder escapes, since they'll be lost anyway.
   if binders [parser] and next (binders [parser]) then
      eprintf ("Warning, bindings in the list parser will be lost")
   end
   return +{ gg.list (-{ `Table{ parser, unpack (qualifiers) } }) }
end

--------------------------------------------------------------------------------
-- builder for `` "keyword" ? ''
--------------------------------------------------------------------------------
function optkey_builder (x)
   assert (x[1].tag=='String', "Only keywords can be made optional")
   return +{ gg.optkeyword{ -{x[2]} } }
end

--------------------------------------------------------------------------------
-- list suffixes: ``until <terminators>'' and ``while <separators>''
--------------------------------------------------------------------------------
function list_qualifiers (lx)
   local t = `Table{ }
   local kw_list = gg.list{ mlp.string, separators = "or", builder='Table' }
   local f = |k| lx:next() and table.insert (t, `Pair{ `String{ k }, kw_list(lx) })
   while true do
      match lx:is_keyword (lx:peek()) with
      | "while" -> f 'separators'
      | "until" -> f 'terminators'
      | _  -> return t
      end
   end
   return t
end

--mlp.expr.transformers:add(|x|eprintf("expr: %s", table.tostring(x, 'nohash')))

-- Forward declaration for self reference
local function _expr_parser (...) return expr_parser (...) end

--------------------------------------------------------------------------------
-- Main parser expression syntax: This parses the content of << ... >>.
--------------------------------------------------------------------------------
expr_parser = gg.expr{ name = "gg parser",

   primary = gg.multisequence{ 
      { "(", _expr_parser, ")", builder = |x| x[1] },
      { "repeat", _expr_parser, list_qualifiers, 
         builder = |x| `List{ x[1], x[2][1], x[2][2] } },
      { mlp.expr, builder = |x| `Lua{ x } }
   },
   
   infix = { 
      { "=",      prec=90, builder = |x| `Bind{ x[1], x[3] } },
      { ",",      prec=50, builder = 'Sequence',       assoc = 'flat' },
      { "|", "|", prec=30, builder = 'Multisequence' , assoc = 'flat' },
      { "=>",     prec=70, builder = |x| `Onkeyword{ x[1], x[3] } },
   }, 

   prefix = { },

   suffix = {
      { "::", mlp.expr, prec=40, builder = |x| `Builder{ x[1], x[2][1] } },
      { "?", builder = 'Optkeyword' }, --FIXME check, most likely false
   }
}

--------------------------------------------------------------------------------
-- Plug parser expression in metalua, between << ... >>
-- ``myparser = << ... >>''
--------------------------------------------------------------------------------
mlp.expr.primary:add{ "<<", expr_parser, ">>", builder = |x| compile(x[1]) }

--------------------------------------------------------------------------------
-- Allow parsers as function parameters without parentheses
-- ``function_accepting_parsers << foo, bar >>''
--------------------------------------------------------------------------------
mlp.expr.suffix:add { 
   "<<", expr_parser, ">>", 
   builder = |f, x| `Call{ f, compile(x[1]) } }

--------------------------------------------------------------------------------
-- Allow parsers as method parameters without parentheses:
-- ``object:method_accepting_parsers << foo, bar >>''
--------------------------------------------------------------------------------
mlp.method_args:add { "<<", expr_parser, ">>", builder = |x| { compile(x[1]) } }

--------------------------------------------------------------------------------
-- Declare a forward parser (i.e. an eta-expansion of a future parser):
-- ``forward some.parser''
--------------------------------------------------------------------------------
mlp.stat:add { "forward", mlp.expr,
   builder = |x| +{stat: (-{x[1]}) = |...| -{x[1]}(...) } }

--------------------------------------------------------------------------------
-- Declare a forward parser, and simultaneously create a local var for it:
-- ``local forward myparser''
--------------------------------------------------------------------------------
local local_parser = mlp.stat :get "local" [2]
local_parser:add{ "forward", mlp.id,
   builder = |x| +{stat: local function -{x[1]} (...) return -{x[1]} (...) end } }


compile = { }
setmetatable (compile, compile)

function compile:__call (ast)
   return self [ast.tag] (self, unpack (ast))
end

function compile:Multisequence (...) 
   local x = `Table{ }
   for i, p in ipairs{ ... } do
      x[i], openvars = self (p)
      -- Make sure that each alternative is a sequence
      match x[i] with 
      | `Call{ +{gg.sequence}, ... } -> -- ok
      | y -> x[i] = +{ gg.sequence{ -{y}, builder = |x| x[1] } } -- convert
      end
      if next (openvars) then
         eprintf ("Warning: lost open variables in a multisequence case")
      end
   return `Call{ +{gg.multisequence}, x }, { }
end

function compile:Sequence(...) 
   local x = `Table{ }
   local openvars = { }
   local j = 0 -- index of the current parser in the sequence's result
   for i, p in ipairs{ ... } do
      local o 
      x[i], o = self (p)
      if x[i].tag ~= "string" then 
         -- build open var accessors
         j += 1 
         for var_name, var_accessor in  pairs (o) do
            openvars [var_name] = `Index{ var_accessor, `Number{ j } }
         end
      else assert (not next(o), "there shouldn't be openvars on a keyword") end
   end
   return `Call{ +{gg.sequence}, x }, openvars
end

function compile:List (p, sep, term)
   local x, o = self (p)
   if next (o) then
      eprintf ("Warning: lost open variables in a list element parser")
   end
   local r = `Call{ +{gg.list}, x }
   local function insert_pair (r, key, values)
      if values and next(values) then
         values.tag = 'Table'
         table.insert (r, `Pair{ `String{ key }, values })
      end
   end
   insert_pair (r, 'separators', sep)
   insert_pair (r, 'terminators', term)
   return r, { }
end

function compile:Onkeyword (kw, p)  
   local x, o = self (p)
   if next (o) then
      -- update accessors
      for var_name, var_accessor in  pairs (o) do
         o [var_name] = ???
      end
   end
   return +{ gg.onkeyword{ -{kw}, -{x} } }
end

<< "else" => e=(mlp.expr, "end") >>
dedans, e -> it[1]
dehors, e -> it and it[1] 

function compile:Optkeyword (...)
   return +{gg.optkeyword -{ {...} } }, { }
end

function compile:Lua (expr)
   return expr, { }
end

function compile:Bind (name, p)
   local x, o = compile (p)
   o [name] = ???eemptypath
   return x, o
end

function compile:Builder (p, expr)
   local x, o = compile (p)
   
   -- We need the result to accept builders
   if p.tag=='Lua' or p.tag=='Optkeyword' then
      x = +{ gg.sequence{ -{expr} } }
   end

   -- Node where the builder will be inserted: 1st arg of `Call
   local parser_arg = x[2]

   -- Build accessors to bound vars

   local fv = freevars (x)
   local vars, accessors = { }, { }
   local getvars = `Local{ vars, accessors }
   for v in keys (fv) if o[v] do
      local accessor = ???
      table.insert (vars, `Id{ v })
      table.insert (accessors, accessor)
   end
   
   -- Builder value:
   local f = +{function (it) -{getvars}; return -{expr} end}

   table.insert (parser_arg, `Pair{ +{"builder"}, f })

   return x, { } -- remove binders (but should I?)

end



function generate_accessor_body (path, n, core)
   
   local x = path[n]
   if not x then return +{it}
   elseif x == 'optional' then
      +{ it = }

 { 1, 3, 'optional' 4 }

 `Stat{ +{local it= -{core}}, +{ -{core} and xx } }

 it[1]
 it[1][3]
 it = it[1][3]; it and 

 it = it[1][3]; it and it[4]

function f (it)
   local foo = it[1][3] foo = foo and foo[4]
   

   local foo = -{ `Stat{ +{block: local it = it[1][3] } }, +{ it and it[4] } }


   f( it, { 1,3,opt,4 } )
   f( it[1], { 3,opt,4 } )
   f( it[1][3], {opt,4 } )
   f( do local it=it[1][3] return f(it, 4) end, { } ) 



   f( it, {1,opt,2,opt,3} )
   f( it[1], {opt,2,opt,3} )
   f( do local it=it[1],


match path with
| { } | { 'optional' } -> return calculi, core
| { 'optional', n, ... } if type(n)=='number' -> 
   table.insert (calculi, +{ it = -{core} })
