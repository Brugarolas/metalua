=== Random personal notes ===

====================================================================
This is my persistent *scratch*. There are random notes, in random
languages, unstructured, out of date, generally unexploitable. Don't
expect anything here to make sense.
====================================================================

Readme fraft
============
This distribution of metalua tries to favor ease of install over
saving a couple of kilobytes; therefore it directly embeds pieces of
useful other free software rather than letting users fetch and
configure them, and it installs separately from a regular lua install,
instead of messing it up.

Open source code used by metalua


Metalua current sources include (possibly slightly modified versions
of) these open source projects:

- Lua, of course.

- Yueliang, a Lua compiler in written in Lua: this is
  the base of metalua's bytecode dumper.

- Rings, a part of the Kelper project, which lets handle multiple Lua
  states from within Lua.

- Editline, an interactive command line editor, very similar to GNU
  readline but with a more permissive licence.

- bitlib for bitwise manipulations (especially useful for bytecode
  dumping)

The mlc module
--------------
This module contains all of the compilation stuff. The version
available after compilation is heavily based on the pattern matching
extension, so it isn't used in the code required for bootstrapping
(which has to be in lua inter metalua. That is, then, Lua)

Libraries
---------
The mechanism of metalua libraries is exactly the same as Lua's,
except that the environment variable names ahve been changed to allow
peaceful cohabitation with Lua.

Etancheite:
===========
- shell interactif:
  * separer les niveaux
  * permettre de monter/descendre d'un niveau avec des commandes
    dediees: "+:" et "-:"

Il faut faire la part entre la synthese de l'AST et l'evaluation. La
synthese de l'AST est faite en amont de mlc.splice(). Apparemment, le
lexer est commun a tout le monde... et mlp aussi.

Hygiene:
========
les quotes peuvent etre hygieniques (HQQ) ou pas (QQ). les QQ sont
normales, ne font rien; ca permet de capturer des variables entre
morceaux. 

Les HQQ sont attachees a un contexte, dans lequel seront reversees
leurs variables libres. +{:hexpr(CTX): foo } va alpha renommer toutes
les variables libres de +{foo} et les stocker dans CTX.

Autre possibilite syntaxique: une +{hexpr: foo } retourne +{foo} et
son contexte. Le contexte permet de decider comment fusionner deux
AST. Il ne se resume pas a une substitution

->Laurie:

Your approach is to tell the user that an AST has a sense by itself:
it's an autonomous piece of data that won't interfere with its
environment. Then you re-introduce mechanisms to get some dangling
bits back, so that you can wire the various bits (QQ and splices)
together as you wish. 

Now, the point from which I'll draw my PoV: an AST is only hygienic
relative to a context. Through gensym() we're able to craft ASTs that
are hygienic in all normal contexts, but the notion of contexts
continues to exist. In particular, as soon as we want to connect bits
of AST in interesting ways, we start to need a finer-grained control
of contexts.

You offer, with $c{ } ${ } and &, ways to poke holes into contexts,
but since you try pretend to the user that there's no context, the
user is screwed when he does want to mess with it. He has to guess how
those hidden contexts work, and find ways to use the tools mentionned
above so that they have the intended effect on the stealth context.

That's a good approach when there's nothing clever to do with
contexts, and it falls down when users get out of the main use
cases. Depending on how rare it is to need such conttext hacking
capabilities, your approach might or might not be practical.

The metalua-consistent approach is the opposite one: if there's such a
thing as contexts, and it sometimes makes sense for (advanced) users
to fiddle with them, then there must be first class AST context
objects. If it can be optionally hidden in most common cases, great,
but users aren't supposed to ignore their existence.

Therefore, whenever you combine two pieces of AST, you specify how
their context must be merged. The 2 most common defaults would be
"don't touch anything" (non-hygienic macros) and "make sure there's no
interference" (full hygiene, no capture). 

In the example we just discussed, the problem is that we have 3 AST
(around, inside and usercode) and we want to splice them in a fancy
way: there's only one capturing variable between around and inside,
and it must not capture anything in usercode. You hack your way around
to build a protective shell on usercode, then toss it with the other
ASTs. I'd rather write that around and inside share the same context,
and usercode has its own. Then when combining all those, the
hygienizer will know what to do. if I wanted to combine around's and
outside's contexts so that they'd only share "q_var", I should be able
to express that as well.

Bottom line is: I'd rather have 1st class context than implicit ones,
which will be a hassle to interact with when I have to. KISS
engineering at its best :)



Restent a faire:
================
- reflechir a l'addition automatique des mots-clef par les parsers qui
  vont bien. Peut-etre qu'ils sont attaches optionnellement a un lexer,
  et que cet attachement est transmis par defaut qd on insere un
  parser ds un autre
- notation pour la generation auto de sous-tables
- verifier le runtime error handling patch d'EVE
- anaphoric macros should bind 'it' to a function when it appears directly in
  it. it would allow anonymous recursive functions. However, anaphoric
  structures tend to capture each other very fast; maybe Arc has insightful
  ideas about this? (e.g. different captured names for function and other
  structs)


Bugs a verifier:
================
- reentrance de in_a_quote dans mlp_meta.lua
- refuser les flags autres qu'expr dans les splices in_a_quote

il faudra encore fournir une boucle interactive, celle de lua n'est
pas patchable. Idem pour le compilo.

metalua compiler/interpreter short usage manual
===============================================

Allows to compile and/or run metalua programs, and to use interactive
loop.

--compile
--run
--interactive
--output
--load-library <name>[@metalevel]
--print-ast

By default, parameters are passed to all running chunks. However, if
there is are parameters and no running chunk, the first parameter is
taken as the running chunk.

metalua --compile foo.mlua 

if there is an --output, all run and compiled files will be saved in
it.

- compile all files.
- displays ASTs depending on --print-ast
- run all files if --run
- run loop after compile and run if -i or if no file
- if no -a and no -o, -x is implied
- if -x and no file, first param is a file

2nd attempt
===========

Compile and/or execute metalua programs. Parameters passed to the
compiler should be prefixed with an option flag, hinting what must be
done with them: take tham as file names to compile, as library names
to load, as parameters passed to the running program... When option
flags lack, metalua tries to adopt a "Do What I Mean" approach:

- if no code (no library, no literal expression and no file) is
  specified, the first flag-less parameter is taken as a file name to
  load.

- if no code and no parameter is passed, an interactive loop is
  started.

- if a target file is specified with --output, the program is not
  executed by default, unless a --run flag forces it to. Conversely,
  if no --output target is specified, the code is run unless ++run
  forbids it.

When does it compile, when does it execute?
------------------------------------------- 
The result of the compilation is saved if there is a --output
specifying a destination file. If not, the result is run. If both
--output and --run are specified, the result is both saved and run. If
the compilation must be saved, it is mandatory to have at least one
file or library. 

How to load chunks to compile/run
---------------------------------
Files can be passed, with their relative paths, with --file. Libraries
can be loaded, from standard paths, with --library. Litteral blocks of
code can be passed with --literal.

When does it launch an interactive loop?
----------------------------------------
When --interactive is specified, or when no chunk is loaded.




Macro hygiene
=============

alpha should go at the top of the chunk *where the quote is used*,
which is generally not the same as where it's defined. Ideally, it
should go where the extension using the quote is called. So what I
really need is an improved 'extension' statement, which handles quotes
anhoring.

A serious problem is that most quotes are inside functions and
therefore not always evaluated in the extension() call.

Let's consider two instants:
- when the QQ is formally created for compilation (1)
- when it's returned by a function, presumably to be spliced (2)


 If alpha-conv
happens at QQ creation, then I lose the


So, alpha
conversion must happen at CT


